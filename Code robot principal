/*----------------------------------------------------------------------------*/
/* Copyright (c) 2017-2018 FIRST. All Rights Reserved.                        */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/
//Ps. oui il n'y a pas d'accent. Fichtre d'ASCII

//Nom du projet
package org.usfirst.frc.team6929.robot;


import com.kauailabs.navx.frc.AHRS;

//Importations de code de la librairie de first

import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Encoder;

//-----------------Fin des importations et debut du code!--------------------------------

//On annonce la classe. C'est une classe TimedRobot, 
//ce qui signifie qu'elle va etre appelee (Utilisee toutes les 20 ms (Constant))

public class Robot extends TimedRobot {
//On annonce les differentes variables des pieces du robot
	
	VictorSP leftMotor = new VictorSP(0);
	VictorSP rightMotor = new VictorSP(1);
	Spark MPR1 = new Spark(2);
	Spark MPC1 = new Spark(3);
	Spark MPC2 = new Spark(4);
	Spark MPelle1 = new Spark(5);
	private DifferentialDrive m_robotDrive = new DifferentialDrive(leftMotor, rightMotor);
	private Joystick m_stick = new Joystick(0);
	//private ADXRS450_Gyro gyro = new ADXRS450_Gyro();
	private Timer limit_timer = new Timer();
	private Timer yButtonTimer = new Timer();
	private Timer PID_timer = new Timer();
	private Timer retourTimer = new Timer();
	 AHRS ahrs;
     DigitalInput limitswitchPince;

Encoder encGauche;
Encoder encDroit;
Encoder encPelle;
Encoder encPince;
//Chooser
	//Ce sont les variables permettant de choisir le mode autonome avant le match
	//Elles sont un peu speciales a cause de cela
	
		private static final String kDefaultAuto = "Mode default";
		private static final String kCustomAuto1 = "Mode 1";
		private static final String kCustomAuto2 = "Mode 2";
		private static final String kCustomAuto3 = "Mode 3";
		private static final String kCustomAuto4 = "Mode 4";
		private static final String kCustomAuto5 = "Mode 5";
		private static final String kCustomAuto6 = "Mode 6";
		private String m_autoSelected;
		private SendableChooser<String> m_chooser = new SendableChooser<>();
	
	
//PID
	//Les variables pour le regulateur PID (proportionnel, integral, derive)
	
	//Des constantes de PID qui marchent bien avec le robot

        private static final double kP = -0.04; // -0.035
		private static final double kI = 0;    
		private static final double kD = -0.065; //-0.065
		
	//Ont annonce le controlleur PID
		private PIDController r_pidController;
		private PIDController l_pidController;
	    private PIDController encPelle_pidController;
		private PIDController encPince_pidController;
	//Les variables du pneumatic
//		DoubleSolenoid exampleDouble = new DoubleSolenoid(0, 7);
	//	DoubleSolenoid pneuPince = new DoubleSolenoid(1, 6);
//		DoubleSolenoid pneuPelleR = new DoubleSolenoid(0, 7);
	//	DoubleSolenoid pneuPelleL = new DoubleSolenoid(1, 6);
		
	//Ah ce tres cher Network Table
	NetworkTableEntry xCenterEntry;
	 double[] centerX;
	
	 
	
	//Variables personnalisees (Qui ne sont que des variables fictives et non pas des elements du robot)
	
	boolean Bbuton = false;
	boolean Ybuton = false;
	boolean lent = true;
	boolean lentTrigger = false;
	boolean YbutonTrigger = false;
	boolean premiereMesure = false;
	boolean auto1 = false;
	boolean auto2 = false;
	boolean auto3 = false;
	boolean auto4 = false;
	boolean auto5 = false;
	boolean auto6 = false;
	boolean auto7 = false;
	double objRetour = 0;
	double objectifStraight = 0;
	boolean yButonAngle = false;
	boolean retourAuto = false;
	int rotationPelle=1;
//Fin de l'annonce des variables

//-----------------------Lancement du robot------------------------------------------
	@Override
	public void robotInit() {
	      try {
	          ahrs = new AHRS(SPI.Port.kMXP); 
	      } catch (RuntimeException ex ) {
	          DriverStation.reportError("Error instantiating navX-MXP:  " + ex.getMessage(), true);
	      }
//On setup certaines pieces des le demarage
	      ahrs.reset();
		UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
		camera.setResolution(640, 360);
		camera.setFPS(15);

		limitswitchPince = new DigitalInput(8);


		//Encoders
//Enc 1 = encoder de la pince
		encDroit = new Encoder(0, 1, false, Encoder.EncodingType.k1X);
		encGauche = new Encoder (2,3, false, Encoder.EncodingType.k1X);
		encPelle = new Encoder(4,5,false, Encoder.EncodingType.k1X);
		encPince = new Encoder(6,7,false, Encoder.EncodingType.k1X);
	//	enc1.setDistancePerPulse(360/497);
		
//Les trois versions du code de pneumatic qu'on peut utiliser, a se rappeler
		//exampleDouble.set(DoubleSolenoid.Value.kOff);
		//exampleDouble.set(DoubleSolenoid.Value.kForward);
		//exampleDouble.set(DoubleSolenoid.Value.kReverse);
		
		
//Network Tables
	//On commence a collecter les donnes du network
	
		NetworkTableInstance inst = NetworkTableInstance.getDefault();
		NetworkTable table = inst.getTable("GRIP/Contours");
		xCenterEntry = table.getEntry("centerX");
		
//Selection mode auto
	//On ajouter des options de mode autonomes
	
			m_chooser.addDefault("Mode default", kDefaultAuto);
			m_chooser.addObject("Mode 1", kCustomAuto1);
			m_chooser.addObject("Mode 2", kCustomAuto2);
			m_chooser.addObject("Mode 3", kCustomAuto3);
			m_chooser.addObject("Mode 4", kCustomAuto4);
			m_chooser.addObject("Mode 5", kCustomAuto5);
			m_chooser.addObject("Mode 6", kCustomAuto6);
	
	//Et on les mets sur le dashboard		
	
			SmartDashboard.putData(m_chooser);
		    
//PID
	//On active le PID
	
		r_pidController = new PIDController(kP, kI, kD,  ahrs, leftMotor);
		l_pidController = new PIDController(kP, kI, kD, ahrs, rightMotor);
		
		
		
		r_pidController.setInputRange(-180, 180);
		l_pidController.setInputRange(-180, 180);
		r_pidController.setContinuous();
		l_pidController.setContinuous();
		
		
		encPelle_pidController = new PIDController(0 , 0 , 0 , encPelle, MPelle1);
		 encPince_pidController = new PIDController(0.175, 0 , 0 , encPince, MPR1);

//Fin du robot init	
	}

//-----------------------------On start le mode autonome------------------------- 
	@Override
	public void autonomousInit() {
	//Ont active certains systemes
		encPince.reset();
		encPelle.reset();
		encGauche.reset();
		encDroit.reset();
		
		limit_timer.reset();
		retourTimer.reset();
		PID_timer.reset();
		
		limit_timer.start();
		
		r_pidController.disable();
		l_pidController.disable();
		
		m_autoSelected = m_chooser.getSelected();
		System.out.println("Auto selected: " + m_autoSelected);
		
		auto1 = false;
		auto2 = false;
		auto3 = false;
		auto4 = false;
		auto5 = false;
		auto6 = false;
		auto7 = false;
		
		ahrs.reset();
		ahrs.resetDisplacement();
//Fin de autonomousInit
	}


//--------------------Mode autonome (Durant)----------------------------------
//--------------------En chantier---------------------------------------------

	@Override
	public void autonomousPeriodic() {
	
	//On selectione le mode autonome choisit
	
		switch (m_autoSelected) {
		case kCustomAuto1:
			 SmartDashboard.putNumber("Ok",1);
			 
//--------------------------Variables auto 1-----------------------------------
			 
					int count = encGauche.get();
					double roue = count/480;
			//480 = un tour
			
			
//----------------------Debut mode autonome 1--------------------------
			
			if(roue  < 3.49 && retourAuto == false) {
				
				double turningValue = -ahrs.getAngle();
				SmartDashboard.putNumber("Turning Value", turningValue);

				if(turningValue > 0.3) {
					turningValue = 0.3;
				}
				
				if (turningValue < -0.3) {
					turningValue = -0.3;
				}

				m_robotDrive.arcadeDrive(0.7, -turningValue * 0.7);
				
			}else if (PID_timer.get() < 4  && retourAuto == false ){
				if(auto1 == false) {
					PID_timer.start();
					ahrs.reset();
					encGauche.reset();
					r_pidController.enable();
					l_pidController.enable();
					r_pidController.setSetpoint(52);
					l_pidController.setSetpoint(52);
					auto1 = true;
				}
			
			}else if (PID_timer.get() > 4 && roue < 4 && retourAuto == false) {
				if(auto2 == false) {;
				encGauche.reset();
					ahrs.reset();
					
					r_pidController.disable();
					l_pidController.disable();
					
					auto2 = true;
				}
				
				double turningValue = -ahrs.getAngle() ;
				SmartDashboard.putNumber("Turning Value", turningValue);
				
				if(turningValue > 0.5) {
					turningValue = 0.5;
				}
				if (turningValue < -0.5) {
					turningValue = -0.5;
				}
				
				m_robotDrive.arcadeDrive(0.5, -turningValue * 0.7);
				
			}else if (roue < 8 && retourAuto == false){
				if(auto5 == false) {
					ahrs.reset();
					auto5 = true;
		
					r_pidController.enable();
					l_pidController.enable();
					r_pidController.setSetpoint(-90);
					l_pidController.setSetpoint(-90);
				}
				
			}else if (roue < 10 && retourAuto == false){
				if(auto6 == false) {
					ahrs.reset();
					
					r_pidController.disable();
					l_pidController.disable();
					
					encPince_pidController.enable();
					encPince_pidController.setSetpoint(124);
					
					auto6 = true;
				}
				
				double turningValue = -ahrs.getAngle() ;
				SmartDashboard.putNumber("Turning Value", turningValue);
				
				if(turningValue > 0.5) {
					turningValue = 0.5;
				}
				if (turningValue < -0.5) {
					turningValue = -0.5;
				}
			
				m_robotDrive.arcadeDrive(0.5, -turningValue * 0.7);
				
			}else if (roue  > 14 || retourAuto == true ){
				retourAuto = true;
				if(limitswitchPince.get() == true) {
					
					double[] gripValuesX = new double[0];
					double[] XValue =  xCenterEntry.getDoubleArray(gripValuesX);
					double angleVise = 320 / 10.333;
	
					double calcul = 0;
					
					if(XValue.length != 0) {

							if(premiereMesure == false) {
								encGauche.reset();
								double trouve =  XValue[0] / 10.333;
								SmartDashboard.putNumber("Trouve", trouve);
								
								MPC1.set(0.35);
								MPC2.set(-0.35);
								
								ahrs.reset();
								premiereMesure = true;  
								
								calcul = angleVise - trouve;
								SmartDashboard.putNumber("Calculs", calcul);
							}
							
							if(premiereMesure == true) {
								double angleGyro = ahrs.getAngle();
								SmartDashboard.putNumber("Angle Gyro", angleGyro);
								double setPoint = calcul - angleGyro ;
								SmartDashboard.putNumber("Set Point", setPoint);
								m_robotDrive.arcadeDrive(0.7, setPoint * 0.025);
							}

					}else {
						m_robotDrive.arcadeDrive(0, 0.4);
					}
						
				}else if( roue < 3) { //Nombre encoder (
	 			if(auto3 == false)
	 			{
	 				MPC1.set(0);
	 				MPC2.set(0);
	 			}
	 			
	 			double turningValue = -ahrs.getAngle();
				
				if(turningValue > 0.3) {
					turningValue = 0.3;
				}
				if (turningValue < -0.3) {
					turningValue = -0.3;
				}
	 			
				m_robotDrive.arcadeDrive(-0.7, turningValue * 0.2);
	 			
				} else if (retourTimer.get() < 5) {
					
					if(auto7 == false) {
						ahrs.reset();
						auto7 = true;
			
						r_pidController.enable();
						l_pidController.enable();
						r_pidController.setSetpoint(-90);
						l_pidController.setSetpoint(-90);
					}
				
	 		} else if (retourTimer.get() < 7) {
				double turningValue = -ahrs.getAngle();
				SmartDashboard.putNumber("Turning Value", turningValue);
				
				if(turningValue > 0.3) {
					turningValue = 0.3;
				}
				if (turningValue < -0.3) {
					turningValue = -0.3;
				}
				m_robotDrive.arcadeDrive(-0.7, turningValue);
				
	 		} else if (retourTimer.get() < 7) {
	 			if(auto1 == false) {
	 				ahrs.reset();
	 				auto1 = true;
	 				r_pidController.enable();
	 				l_pidController.enable();
	 				r_pidController.setSetpoint(-52);
	 				l_pidController.setSetpoint(-52);
	 			}
	 		} else if (retourTimer.get() < 10) {
				double turningValue = -ahrs.getAngle() ;
				SmartDashboard.putNumber("Turning Value", turningValue);
				
				if(turningValue > 0.5) {
					turningValue = 0.5;
				}
				if (turningValue < -0.5) {
					turningValue = -0.5;
				}
				m_robotDrive.arcadeDrive(0.5, turningValue);
	 		} else if (retourTimer.get() > 12) {
				MPC1.set(-0.75);
				MPC2.set(0.75);
	 		}
			
	}
			
		
			
			break;
			
		case kCustomAuto2:

			break;
			
		case kCustomAuto3:
	
	break;
			
		case kCustomAuto4:

			break;
			
		case kCustomAuto5:

			break;
			
		case kCustomAuto6:
	
		break;
			
			
			
		case kDefaultAuto:
		default:

			break;
	}}
		
			

				 			  
			
			
//Fin du mode autonome 
	//	}
		

//--------------------------Initialisation du mode teleopere--------------------------------
	@Override
	public void teleopInit() {

	//On active nos trucs
		encGauche.reset();
		limit_timer.reset();
		limit_timer.start();
		
		r_pidController.enable();
		r_pidController.setSetpoint(0);
		l_pidController.enable();
		l_pidController.setSetpoint(0);
		
		encPince_pidController.enable();
		encPince_pidController.setSetpoint(124);
		

//Fin de teleopInit
	}

//----------------------------Deroulement du mode Teleop------------------------------------
	@Override
	public void teleopPeriodic() {

//Network Tables
	//C'est la qu'on va mettre nos Network Tables, si besoin est	

		if(m_stick.getRawButton(3)==true&&rotationPelle==1) {
			encPelle_pidController.enable();
			encPelle_pidController.setSetpoint(45);
			rotationPelle=rotationPelle + 1;
			}
			else if(m_stick.getRawButton(3)==true&&rotationPelle==2) {
			encPelle_pidController.enable();
			encPelle_pidController.setSetpoint(90);
		//	pneuPelleR.set(DoubleSolenoid.Value.kForward);
		//	pneuPelleL.set(DoubleSolenoid.Value.kForward);
			rotationPelle=rotationPelle + 1;
			}
			else if(m_stick.getRawButton(3)==true&&rotationPelle==3) {
			encPelle_pidController.enable();
			encPelle_pidController.setSetpoint(45);	
		//	pneuPelleR.set(DoubleSolenoid.Value.kReverse);
		//	pneuPelleL.set(DoubleSolenoid.Value.kReverse);
			rotationPelle=rotationPelle + 1;
			}
			else if(m_stick.getRawButton(3)==true&&rotationPelle==4) {
			encPelle_pidController.enable();
			encPelle_pidController.setSetpoint(0);			
			rotationPelle=1;
			}
		
	//Activer les roulettes de la pince(R1 et L1)
		
		if(m_stick.getRawButton(5) == true) {
			MPC1.set(-0.75);
			MPC2.set(0.75);
		} else if(limitswitchPince.get() == true && m_stick.getRawButton(6) == true)	{
		 
			MPC1.set(0.35);
			MPC2.set(-0.35);
	 
		}else {
			MPC1.set(0);
			MPC2.set(0);
		}
		
		//Deployer/controller la pince
			if(m_stick.getRawButtonPressed(7) == true) {
				encPince_pidController.disable();
				MPR1.set(0.4);
			}else if (m_stick.getRawButtonPressed(8)) {
				encPince_pidController.disable();
				MPR1.set(-0.4);
			} else if (limit_timer.get() >= 1.5){
				MPR1.set(0);
			}
			
//------------------------------------------Conduite-------------------------
		
		
	//ici, on verifie si les boutons B et Y ne sont pas actionnes
		if(Bbuton == false && YbutonTrigger == false) {
		
		//Desactivation du pid
			r_pidController.disable();
			l_pidController.disable();
		
		//Creation de l'effet de toggle 
			if(m_stick.getRawButtonPressed(9) == true) {
				lent = !lent;
				}
			
			
		//Mode lent	
			if (lent == false){
				double ystick = m_stick.getRawAxis(2) *0.6 - m_stick.getRawAxis(3) * 0.6;
				double xstick = - m_stick.getRawAxis(0) * 0.6;
				m_robotDrive.arcadeDrive(-ystick, xstick);
				}
			
		//Mode rapide
			else if (lent == true) {
				double ystick = m_stick.getRawAxis(2) * 2 - m_stick.getRawAxis(3);
				double xstick = - m_stick.getRawAxis(0) * 0.75;
				m_robotDrive.arcadeDrive(-ystick, xstick);
				}
			
			}
		
		//Les gyros
		double angle = ahrs.getAngle();
		double angleabs = angle;
		
		
		//----------------Calcul d'angle---------------------
		// De infinie vers -360 a 360
		if(angleabs > 0) {
			double a = angleabs / 360;
			int b = (int)a;
			double c = angleabs - (b * 360);
			if(c > 180) {
				c -= 360;
			}
			else if(c <= 180) {
				
			}
			angleabs = c;
		}
		else if(angleabs < 0) {
			double a = angleabs / 360;
			int b = (int)a;
			double c = angleabs - (b * 360);
			if(c < -180) {
				c += 360;
			}
			else if(c >= -180) {}
			angleabs = c;
		}
		else {}
		
		SmartDashboard.putNumber("Gyro angle", angle);
		SmartDashboard.putNumber("Gyro angle (ABS)", angleabs);
		
		//-----------Fin du calcul d'angle---------------
		
		
		//----------------A Button------------------------
		if( m_stick.getRawButtonPressed(1) == true){
			ahrs.reset();
			r_pidController.setSetpoint(0);
			l_pidController.setSetpoint(0);
		//	pneuPince.set(DoubleSolenoid.Value.kReverse);	
			}		
			

		//----------------------------B buton-----------------------------------
		//Garder B button enfonce pour qu'il finisse
		
		if(m_stick.getRawButton(2) == true && Bbuton == false) {
		//Activation du PID	
			double gyroRaw = ahrs.getRawGyroX();
			ahrs.reset();
			
			SmartDashboard.putNumber("Raw Gyro", gyroRaw);
			r_pidController.enable();
			l_pidController.enable();
			double obj = angle +180;
			r_pidController.setSetpoint(obj);
			l_pidController.setSetpoint(obj);
			Bbuton = true;
			SmartDashboard.putNumber("PID objectif", obj);
		//	pneuPince.set(DoubleSolenoid.Value.kForward);
			}
		
	//Eviter 3000 fois le meme bouton. S'active quan on lache le bouton
		if(m_stick.getRawButton(2) == false) {
			Bbuton = false;
			}
			
		//-----------------------Ybuton----------------------------
	//Si ont touche au button Y
		if(m_stick.getRawButton(4) == true && Ybuton == false){
			Ybuton = true;
			
			
		//Si toggle pas active
			if(YbutonTrigger == false){
				yButtonTimer.reset();
				yButtonTimer.start();
				
				} else {
					yButtonTimer.stop();
					yButtonTimer.reset();
					r_pidController.disable();
					l_pidController.disable();
					
		//			exampleDouble.set(DoubleSolenoid.Value.kReverse);
					}
		//La raison pourquoi il toggle		
			YbutonTrigger = !YbutonTrigger;
			}
		//Quand on lache le bouton
			if(m_stick.getRawButton(4) == false) {
				Ybuton = false;
			}
	
		//Si toggle == oui
			if(YbutonTrigger == true && yButtonTimer.get() >= 1) {
			if(yButonAngle == false) {
				objectifStraight = ahrs.getAngle();
				yButonAngle = true;
			}
			//Setup le "PID" pour rester droit
			double turningValue = -ahrs.getAngle() + objectifStraight  ;
			SmartDashboard.putNumber("Turning Value", turningValue);
			
			if(turningValue > 0.6) {
				turningValue = 0.6;
			}
			if (turningValue < -0.6) {
				turningValue = -0.6;
			}
			m_robotDrive.arcadeDrive(0.65, -turningValue * 0.7);
				}
	
//Fin du teleop	
	}
	
	@Override
	public void testPeriodic() {
	}
}
